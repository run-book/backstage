import { CommandContext } from "./context";
import { applyCatalogTemplateForKind, applyRootCatalogTemplate, catalogTemplateDic, rootCatalogTemplateDictionary, templateDir } from "./templates";
import { Command } from "commander";
import { findAllChildPomDependencies, findModuleDepenciesAndNameFromPom, loadAndListPomModules } from "./pom";
import { FileAndKind, listFilesRecursively, makeRelative, searchDirectoryForBackstageFiles } from "./file.search";
import { ModDependenciesAndName, ModuleDependency, RawModuleData } from "./module";
import { FileOps } from "@laoban/fileops";
import { findModuleDependenciesAndNameFromPom } from "./npm";


export function addFindCommand ( context: CommandContext ) {
  context.command.command ( "find" )
    .description ( "finds the files 'backstage.xxx.yaml in the repo" )
    .option ( '--debug' )
    .action ( async ( opts ) => {
      const { command, fileOps, currentDirectory } = context
      const dir = command.optsWithGlobals ().directory ?? currentDirectory
      let dirs: FileAndKind[] = await searchDirectoryForBackstageFiles ( fileOps, dir );
      dirs.forEach ( dir => console.log ( dir ) )
    } )

}

export function addNukeCommand ( context: CommandContext ) {
  context.command.command ( "nuke" )
    .description ( "removes all the autogenerated catalog-info.yaml files" )
    .option ( '--debug' )
    .action ( async ( opts ) => {
      const { command, fileOps, currentDirectory } = context
      const dir = command.optsWithGlobals ().directory ?? currentDirectory
      let files = await listFilesRecursively ( fileOps, dir, f => f.endsWith ( 'catalog-info.yaml' ) )
      files.forEach ( async f => {
        const contents = await fileOps.loadFileOrUrl ( f )
        if ( contents.startsWith ( "# Autogenerated by backstage-cli" ) ) {
          console.log ( 'deleting', f )
          await fileOps.removeFile ( f )
        } else if ( opts.debug ) console.log ( 'not deleting', f )
      } )
    } )
}


async function findModuleDependenciesAndName ( fileOps: FileOps, dir, opts, debug ) {
  const fromPom: ModDependenciesAndName | undefined = await findModuleDepenciesAndNameFromPom ( fileOps, dir, opts, debug );
  if ( fromPom !== undefined ) return fromPom
  const fromNpn = await findModuleDependenciesAndNameFromPom ( fileOps, dir, opts, debug );
  if ( fromNpn !== undefined ) return fromNpn
  throw new Error ( `Searching directory ${dir}. Unable to find pom.xml at that location or any package.json under it` )
}
export function addMakeCatalogCommand ( context: CommandContext ) {
  context.command.command ( "make" )
    .description ( "makes the catalog entries" )
    .option ( '--dryrun', 'Just print what would happen' )
    .option ( '-t|--template <template>', 'file or url root for templates', templateDir )
    .option ( '-o|--owner <owner>', 'owner of the catalog', 'Not Known' )
    .option ( '-l|--lifecycle <lifecycle>', 'lifecycle of the catalog', 'experimental' )
    .option ( '-n|--name <name>', 'name of the root componment', )
    .option ( '--debug' )
    .action ( async ( opts ) => {
      const { owner, lifecycle, dryrun, debug, template } = opts
      const { command, fileOps, currentDirectory } = context
      const dir = command.optsWithGlobals ().directory ?? currentDirectory
      let dirs: FileAndKind[] = await searchDirectoryForBackstageFiles ( fileOps, dir );
      const relativeDirs = dirs.map ( f => f.file ).map ( makeRelative ( fileOps, dir ) )
      const { name, modData } = await findModuleDependenciesAndName ( fileOps, dir, opts, debug );
      const realName = opts.name ?? name
      if ( realName === undefined ) throw new Error ( `Unable to find a name for the root component. Use --name` )
      const rootCatalogDic = rootCatalogTemplateDictionary ( realName, modData, relativeDirs )
      const rootCatalog = await applyRootCatalogTemplate ( fileOps, template, rootCatalogDic )


      await Promise.all ( modData.map ( async md => {
        const catalogDic = catalogTemplateDic ( owner, md, lifecycle )

        let catalog = await applyCatalogTemplateForKind ( fileOps, template, md.sourceType, md.kind, catalogDic )
        if ( debug ) catalog = catalog + "\n#DEBUG\n" + JSON.stringify ( catalogDic, undefined, 2 ) + "\n#DEBUG\n" + JSON.stringify ( md, undefined, 2 )
        const filename = fileOps.join ( dir, md.module, `catalog-info.yaml` )
        if ( dryrun ) {
          console.log ( 'filename', filename )
          console.log ( catalog )
          console.log ()
        } else
          await fileOps.saveFile ( filename, catalog )
      } ) )
      if ( dryrun ) {
        console.log ( 'filename', fileOps.join ( dir, `catalog-info.yaml` ) )
        console.log ( rootCatalog )
        console.log ()
      } else
        await fileOps.saveFile ( fileOps.join ( dir, `catalog-info.yaml` ), rootCatalog )
    } )
}

export function addCatalogCommands ( context: CommandContext ) {
  const command: Command = context.command.command ( 'catalog' ).description ( 'commands to setup backstage catalogs' )
  const newContext: CommandContext = { ...context, command }
  addMakeCatalogCommand ( newContext );
  addFindCommand ( newContext );
  addNukeCommand ( newContext );
}